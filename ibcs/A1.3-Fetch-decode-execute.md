---
layout: default
---

<div style="text-align:center; margin-bottom:24px;">
  <h1 style="font-size:26pt; font-weight:700;">A1.3 The Fetch-Decode-Execute Cycle</h1>
  <p style="font-size:14pt;">Understanding how the CPU processes instructions</p>
</div>

---

## <span style="font-size:26pt;">What is the Fetch-Decode-Execute Cycle?</span>

The **fetch–decode–execute cycle**, also known as the **"instruction cycle"**, is the fundamental process that a CPU uses to execute instructions. The cycle consists of three main stages:

1. **Fetch:** Load the next instruction from memory
2. **Decode:** Interpret the instruction and prepare the necessary operations
3. **Execute:** Carry out the actions required by the instruction

![Fetch-Decode-Execute Cycle](./images/fde-cycle.png)

---

## <span style="font-size:26pt;">The Three Stages Explained</span>

### Stage 1: Fetch

The CPU uses the **program counter (PC)** to know which instruction to fetch next:

1. The **PC** (program counter) is currently set to 0, so the instruction at memory location 0 is fetched
2. The address (0) is placed into the **MAR** (memory address register)
3. The instruction is opened in RAM using the **address bus** and fetching the 0 address
4. The **control bus** sends a read signal to initiate this process
5. The instruction is stored in the **instruction register (IR)** and the address (0) is stored in the **MAR**
6. While this happens, the PC gets incremented to 1 via the ALU, ready for the next instruction

---

### Stage 2: Decode

Once the instruction is fetched, the CPU decodes the instruction:

1. The CPU decodes the instruction stored in the **IR**
2. The **control unit** uses the **control bus** to coordinate this process
3. The instruction register gives the location of where to store the data
4. For example, instruction "LDA 4" decodes as "load into the accumulator from address 4"
5. The **address register** is given the address of the data to load (4)

---

### Stage 3: Execute

The CPU performs the actions required by the instruction:

1. The command is then carried out
2. For example, address 4 is opened via the **address bus**
3. The **control bus** sends the appropriate signals to retrieve the data (23) from that location on the **data bus**
4. The data is then stored into the **accumulator** (AC)

---

## <span style="font-size:26pt;">Little Man Computer (LMC) Model</span>

An easier way to see these stages carried out in more detail is to use an educational CPU model known as the **Little Man Computer**. You can search for online simulators available here: [https://peterhigginson.co.uk/lmc](https://peterhigginson.co.uk/lmc).

This model uses **assembly language** – a simple set of instructions, each represented by three letters, which is stored as a three-digit code in the memory. The full set of instructions is:

| Instruction | Code | Description |
|-------------|------|-------------|
| **INP** | 901 | Input a value and store it in the accumulator |
| **OUT** | 902 | Output the value from the accumulator |
| **DAT** | N/A | Used to define data values directly in memory at the point of declaration, often for constants or variables |
| **LDA** | 5XX | Load the value from the specified memory address into the accumulator |
| **STA** | 3XX | Store the value in the accumulator at the specified memory address |
| **ADD** | 1XX | Add the value from the specified memory address to the accumulator |
| **SUB** | 2XX | Subtract the value from the specified memory address from the accumulator |
| **HLT** | 000 | Halt the program |
| **BRA** | 6XX | Branch (jump) to the specified memory address |
| **BRZ** | 7XX | Branch to the specified memory address if the accumulator is zero |
| **BRP** | 8XX | Branch to the specified memory address if the accumulator is positive |

![Little Man Computer](./images/lmc-model.png)

---

## <span style="font-size:26pt;">LMC Worked Example</span>

Enter the following program into the left-hand column and assemble into RAM. You will see the three-digit representation for each instruction stored at a memory address on the right. For example, **LDA 4** has been stored as **504** at memory address 0.

```
LDA 4
ADD 5
STA 5
HLT
DAT 23
DAT 12
```

### First Cycle

**Click step:**

1. **Fetch:** The PC (program counter) is currently set to 0, so the instruction at memory location 0 is fetched (504) by opening the 0 address in RAM using the address bus and fetching the instruction on the data bus. The control bus sends a read signal to initiate this process. The instruction (5) is stored in the instruction register and (04) is stored in the address register.

   While this happens, you will see the PC gets incremented to 1 via the ALU, ready for the next instruction.

2. **Decode:** Once the instruction is fetched, the CPU decodes the instruction. The control unit uses the control bus to coordinate this process. The instruction stored in the instruction register is 5, which decodes as **"load into the accumulator"**. The address register (04) indicates the address of the data to load.

3. **Execute:** The command is then carried out. Address 4 is opened on the address bus, and the control bus sends the appropriate signals to retrieve the data (23) from that location on the data bus and store it into the accumulator.

---

### Second Cycle

**Click step:**

1. **Fetch:** The CPU now uses the PC to know which instruction to fetch next: 1 is currently stored. Address 1 is opened, and the instruction 105 is fetched. The control bus sends a read signal to initiate this. The instruction (1) is stored in the instruction register and (05) is stored in the address register.

   The PC is incremented to 2 by the ALU.

2. **Decode:** The instruction 1 is decoded as **"add to accumulator"**; the address register is the address of the data to add (5). The control unit uses the control bus to coordinate this.

3. **Execute:** Address 5 is opened, and both the accumulator (currently 23) and the fetched data (12) are passed to the ALU. The result of 23 + 12 is stored in the accumulator (35).

---

### Third Cycle

**Click step:**

1. **Fetch:** The PC is currently 2, so the instruction at memory address 2 is fetched (305). The control bus sends a read signal to initiate this. The instruction (3) is stored in the instruction register, and (05) is stored in the address register.

   The PC is incremented to 3 via the ALU.

2. **Decode:** The instruction 3 decodes as **"store accumulator to address"** and the address register gives the location of where to store the data (05). The control unit uses the control bus to coordinate this.

3. **Execute:** Memory address 5 is opened via the address bus, and the control bus sends the appropriate signals to send the accumulator contents down the data bus and **store** them at address 5 (overwriting the current data).

---

### Fourth Cycle

**Click step:**

1. **Fetch:** The PC is currently 3, so the instruction at memory address 3 is fetched (000). The control bus sends a read signal to initiate this. The instruction (0) is stored in the instruction register, and (00) is stored in the address register.

   The PC is incremented to 4 via the ALU.

2. **Decode:** The instruction 0 decodes as **"halt"**. The control unit uses the control bus to signal this operation.

3. **Execute:** The computer halts all operations and ends the program.

---

## <span style="font-size:26pt;">Common Mistake</span>

**A common mistake is assuming that the program counter (PC) gets updated after the execute stage of the fetch-decode-execute cycle.**

**Reality:** The PC is usually updated **during or immediately after the fetch stage**, so it points to the next instruction in the sequence. This ensures that the CPU always knows where to find the next instruction in the sequence, even before the current instruction is decoded or executed.

---

## Practice Questions WITH Model Answers

### Question 1
**What are the main steps in the fetch-decode-execute cycle, and why is this cycle fundamental to CPU operations?**

**Model Answer:**  
The three main steps are:
1. **Fetch:** The CPU retrieves the next instruction from memory using the program counter.
2. **Decode:** The CPU interprets the instruction to understand what operation is required.
3. **Execute:** The CPU carries out the operation specified by the instruction.

This cycle is fundamental because it allows the CPU to systematically process and execute instructions, enabling all computing tasks.

---

### Question 2
**How does the CPU use the address, data, and control buses during the fetch-decode-execute cycle?**

**Model Answer:**  
- During **fetch**, the **address bus** carries the memory address (from PC/MAR) to RAM, the **control bus** sends a read signal, and the **data bus** brings the instruction back to the IR.
- During **decode**, the control unit uses the **control bus** to coordinate interpretation of the instruction.
- During **execute**, the **address bus** carries the address of data to be accessed, the **control bus** signals read/write operations, and the **data bus** transfers the actual data between CPU and memory.

---

### Question 3
**Why is the interaction between memory and registers crucial during the fetch phase of the CPU cycle?**

**Model Answer:**  
During the fetch phase, the program counter (PC) provides the address of the next instruction, which is copied to the memory address register (MAR). The MAR then uses the address bus to access the correct memory location. The instruction is retrieved via the data bus and stored in the instruction register (IR). This interaction ensures that the CPU always has the correct instruction ready for decoding and execution.

---

### Question 4
**Explain the role of the program counter (PC) in the Little Man Computer model.**

**Model Answer:**  
The program counter (PC) holds the address of the next instruction to be fetched. After an instruction is fetched, the PC is incremented (usually by 1) to point to the next instruction in sequence. This ensures the CPU processes instructions in order. Branch instructions (BRA, BRZ, BRP) can change the PC to jump to different parts of the program.

---

### Question 5
**Describe what happens during the decode stage when the instruction "ADD 5" is processed.**

**Model Answer:**  
During the decode stage, the control unit interprets the instruction code stored in the instruction register. For "ADD 5":
- The instruction code (1) is recognized as an addition operation
- The address (5) is identified as the memory location containing the data to add
- The control unit prepares to fetch the data from address 5 and signals the ALU to perform addition with the current accumulator value

---

## Student Practice Questions (No Answers Provided)

1. Trace through the fetch-decode-execute cycle for the instruction "STA 7" starting from when the program counter holds address 2.

2. Explain how the Little Man Computer model helps students understand the fetch-decode-execute cycle.

3. What would happen if the program counter was not incremented during the fetch stage? Describe the consequences for program execution.

---

## <span style="font-size:26pt;">Programming Exercises</span>

Write an LMC program for each of the following:

1. Input two numbers, add them, and output the result
2. Input a number and output whether it is positive or zero
3. Calculate the sum of the first five natural numbers
4. Input two numbers and output the larger one
5. Input three numbers and output them in ascending order

---

## Rosenshine's Principles Applied

- **Short review:** Begin by revisiting CPU components (PC, MAR, IR, MDR, AC)
- **Small steps:** Each stage (fetch, decode, execute) explained separately with detailed examples
- **Active practice:** LMC exercises allow students to trace through cycles step-by-step
- **Models provided:** Worked example shows complete execution of a simple program
- **Check understanding:** Practice questions test comprehension of each stage
- **Systematic feedback:** Model answers show expected level of detail

---

<div style="text-align:center; margin-top:32px;">
  <a href="./A1.4-Secondary-storage.html" style="font-size:16pt; font-weight:600;">Next: A1.4 Secondary Storage →</a>
</div>
